# 구현

### 문제1) 25305번_커트라인
✏️ 내가 구현한 로직
1. 점수들을 입력받을 때 내림차순으로 정렬


📈 시간 복잡도
<br>O(NlogN) - 기본 정렬 라이브러리

💡 인사이트
<br>불필요한 정렬을 줄이기 - 오름차순으로 정렬 후 역순으로 추출만!


---
### 문제2) 11651번_좌표 정렬하기 2
✏️ 내가 구현한 로직
1. y 좌표로 오름차순

📈 시간 복잡도
<br>O(NlogN) - 기본 정렬 라이브러리

💡 인사이트
<br>sort(), sorted()는 기본적으로 iterable의 첫 번째 원소 기준으로 정렬하고,
<br>만약 첫 번째 원소가 같다면, 두 번째 원소를 기준으로 정렬하는 방식으로 동작함

lambda를 사용 기준을 더 명시적으로 정렬 가능

```array.sort(key=lambda x: (x[0], x[1]))   # y -> x 순으로 정렬```

---
### 문제3) 1181번_단어 정렬
✏️ 내가 구현한 로직
1. lambda 식으로 정렬 조건 명시
   1. 길이순 - len(x)
   2. 길이가 같으면 오름차순 - x

📈 시간 복잡도
<br>O(NlogN) - 기본 정렬 라이브러리

💡 인사이트
<br>오름차순으로 정렬한 뒤 len으로 재정렬해도 결과는 같음

---

### 문제4) 11004번_K번째 수
✏️ 내가 구현한 로직
1. 오름차순 정렬 후 k-1 출력

📈 시간 복잡도
<br>O(NlogN) - 기본 정렬 라이브러리

💡 인사이트
<br>

---
### 문제5) 1026번_보물
✏️ 내가 구현한 로직
1. a는 내림차순으로 정렬
2. b를 오름차순으로 정렬했을 때의 b의 인덱스를 담은 리스트 c 생성
3. a의 내림차순 * b의 오름차순 

📈 시간 복잡도
<br>O(NlogN) - 기본 정렬 라이브러리

💡 인사이트
<br>list의 pop(), remove()를 활용하면 리스트를 추가로 생성하지 않아도 됐었다.

---
### 문제6) 13333번_Q-인덱스
✏️ 내가 구현한 로직
1. k번 이상 인용된 횟수, k번 이하 인용된 횟수 카운팅
2. k번 이상 인용된 횟수 < k => pass
3. k번 이상 인용된 횟수 >= k && (n-k)개가 k번 이하 인용 => return

📈 시간 복잡도

O(N<sup>2</sup>) ➡️ bisect 활용하면 O(N)으로 줄일 수 있음

💡 인사이트
<br>문제 이해가 오래 걸렸다. 문제 정확한 분석 필요
<br>다른 풀이들에서 왜 n-k개가 k번 이하 인용은 따로 구현을 안하는지는 모르겠다...