# 구현

### 문제1) 9934번_완전 이진 트리
✏️ 내가 구현한 로직

💡 인사이트



---
### 문제2) 20291번_파일 정리
✏️ 내가 구현한 로직
1. count() 함수를 사용하기 위해 확장자 리스트를 생성한다.
2. dictionary는 key 순서를 바꿀 수 없으므로 리스트를 오름차순으로 정렬한다
3. dictionary를 생성한다. (key-확장자명, value-카운트)

---
### 문제3) 17413번_단어 뒤집기 2
✏️ 내가 구현한 로직
1. 재귀 함수를 사용해 '<'와 '>'의 인덱스를 반환하는 함수 사용
   - 재귀 함수에서 '<'와 '>'가 없다면 -1 반환
2. 재귀 함수의 return 값을 가지고 조건문 사용
   1. 태그가 없다면 (start = end = -1): 공백으로 슬라이싱하여 리스트에 저장
   2. 태그가 있고, 태그가 문자열의 시작이 아닐 때(start no in 0, -1): '<' 전까지의 문자열을 공백으로 슬라이싱하여 리스트에 저장
   3. 태그가 있고, 태크가 문자열의 시작일 때: '<' ~ '>' 까지를 문자열 형식으로 저장
      - 만약 '>'가 문자열의 끝이라면 break

💡 인사이트
1. 슬라이싱할 때 기준은 사라지지만, 이후에 추가할 수 있음 
   
   ex) result.append(f'<{tag}>')   
2. Stack 자료구조 사용

---

### 문제4) 1316번_그룹단어 체커
✏️ 내가 구현한 로직
1. 연속으로 같은 문자 나오면 pass
2. 연속으로 같은 문자가 나오지 않는데, 이후 문자열에서 나오면 count - 1

💡 인사이트
리스트의 sorted() 함수를 활용할 때, key를 사용해서 정렬할 수 있음
- key=리스트명.find
- 순서대로 확인하면서 등장하는 단어와 동일한 단어로 정렬해주며, 
- 알파벳 순서 상관없이 첫 등장 위치부터 중복되는 단어를 순서대로 나열해 줌 


---
### 문제5) 17276번_배열 돌리기
✏️ 내가 구현한 로직
1. 반시계 방향은 360-반시계 각도를 뺀 값과 같음
2. 대각선과 행/열줄 이외의 숫자는 건드리지 않으므로 새로운 배열에 복사해서 사용
3. 각도를 45로 나누어 몫만큼 돌리는 함수 사용

💡 인사이트
- 깊은 복사: copy.deepcopy()

---
### 문제6) 20436번_ZOAC 3
✏️ 내가 구현한 로직


💡 인사이트

